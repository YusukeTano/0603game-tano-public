<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 3 ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a1a;
            color: #eee;
            margin: 0;
            padding: 20px;
        }
        
        .test-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 12px;
            border: 3px solid #533483;
        }
        
        .test-section {
            margin: 25px 0;
            padding: 25px;
            background: #16213e;
            border-radius: 10px;
            border-left: 5px solid #4a90e2;
        }
        
        .phase-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .phase-card {
            background: #0f3460;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #533483;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }
        
        .btn {
            padding: 14px 24px;
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #357abd, #2968a3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.3);
        }
        
        .btn.success { background: linear-gradient(135deg, #27ae60, #229954); }
        .btn.warning { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .btn.danger { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        
        .test-status {
            background: #0f3460;
            border: 2px solid #533483;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .status-card {
            background: #2d1b69;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #533483;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #27ae60);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 4px solid;
        }
        
        .test-result.pass { 
            background: rgba(39, 174, 96, 0.1); 
            border-left-color: #27ae60; 
        }
        
        .test-result.fail { 
            background: rgba(231, 76, 60, 0.1); 
            border-left-color: #e74c3c; 
        }
        
        .test-result.warning { 
            background: rgba(243, 156, 18, 0.1); 
            border-left-color: #f39c12; 
        }
        
        .metrics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: #0f3460;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #533483;
            text-align: center;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #4a90e2;
        }
        
        .log-entry {
            margin: 3px 0;
            padding: 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .log-info { background: rgba(74, 144, 226, 0.1); }
        .log-success { background: rgba(39, 174, 96, 0.1); }
        .log-error { background: rgba(231, 76, 60, 0.1); }
        .log-warning { background: rgba(243, 156, 18, 0.1); }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.js"></script>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>ğŸ§ª Phase 3 Managerå±¤ - ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼</h1>
            <p>ã‚·ãƒ¼ãƒ³ç®¡ç†ãƒ»éŸ³éŸ¿çŠ¶æ…‹åˆ¶å¾¡ãƒ»çµ±åˆã‚·ã‚¹ãƒ†ãƒ ç·åˆãƒ†ã‚¹ãƒˆ</p>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š ãƒ†ã‚¹ãƒˆå®Ÿè¡Œåˆ¶å¾¡</h2>
            <div class="controls">
                <button class="btn" id="initAllBtn">å…¨ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</button>
                <button class="btn" id="runBasicTestsBtn">åŸºæœ¬ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="btn" id="runStressTestsBtn">ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="btn" id="runIntegrationTestsBtn">çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="btn" id="runReliabilityTestsBtn">ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="btn warning" id="resetAllBtn">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="testProgress"></div>
            </div>
            <div id="testProgressText">ãƒ†ã‚¹ãƒˆå¾…æ©Ÿä¸­...</div>
        </div>

        <div class="test-section">
            <h2>ğŸ¬ Phase 3.1 ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</h2>
            <div class="phase-grid">
                <div class="phase-card">
                    <h3>SceneManager</h3>
                    <div class="controls">
                        <button class="btn" id="testSceneManagerBtn">ã‚·ãƒ¼ãƒ³ç®¡ç†ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn" id="testTransitionsBtn">é·ç§»ãƒ†ã‚¹ãƒˆ</button>
                    </div>
                    <div class="test-status" id="sceneManagerStatus">å¾…æ©Ÿä¸­</div>
                </div>
                
                <div class="phase-card">
                    <h3>AudioSceneController</h3>
                    <div class="controls">
                        <button class="btn" id="testAudioSceneBtn">éŸ³éŸ¿ã‚·ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn" id="testCrossfadeBtn">ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ</button>
                    </div>
                    <div class="test-status" id="audioSceneStatus">å¾…æ©Ÿä¸­</div>
                </div>
                
                <div class="phase-card">
                    <h3>TransitionController</h3>
                    <div class="controls">
                        <button class="btn" id="testTransitionCtrlBtn">çµ±åˆé·ç§»ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn" id="testParallelBtn">ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆ</button>
                    </div>
                    <div class="test-status" id="transitionCtrlStatus">å¾…æ©Ÿä¸­</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸµ Phase 3.2 éŸ³éŸ¿çŠ¶æ…‹åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</h2>
            <div class="phase-grid">
                <div class="phase-card">
                    <h3>AudioStateManager</h3>
                    <div class="controls">
                        <button class="btn" id="testAudioStateBtn">çŠ¶æ…‹åˆ¶å¾¡ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn" id="testGameStateBtn">ã‚²ãƒ¼ãƒ çŠ¶æ…‹é€£å‹•ãƒ†ã‚¹ãƒˆ</button>
                    </div>
                    <div class="test-status" id="audioStateStatus">å¾…æ©Ÿä¸­</div>
                </div>
                
                <div class="phase-card">
                    <h3>DynamicWaveController</h3>
                    <div class="controls">
                        <button class="btn" id="testWaveAudioBtn">WaveéŸ³éŸ¿ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn" id="testTempoKeyBtn">ãƒ†ãƒ³ãƒãƒ»ã‚­ãƒ¼ãƒ†ã‚¹ãƒˆ</button>
                    </div>
                    <div class="test-status" id="waveAudioStatus">å¾…æ©Ÿä¸­</div>
                </div>
                
                <div class="phase-card">
                    <h3>RealtimeAudioFeedback</h3>
                    <div class="controls">
                        <button class="btn" id="testRealtimeBtn">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn" id="testFeedbackBtn">ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ</button>
                    </div>
                    <div class="test-status" id="realtimeStatus">å¾…æ©Ÿä¸­</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ”— Phase 3.3 çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</h2>
            <div class="phase-card">
                <h3>Phase3ManagerIntegration</h3>
                <div class="controls">
                    <button class="btn" id="testIntegrationBtn">çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</button>
                    <button class="btn" id="testEventBusBtn">ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹ãƒ†ã‚¹ãƒˆ</button>
                    <button class="btn" id="testGameHooksBtn">ã‚²ãƒ¼ãƒ é€£æºãƒ†ã‚¹ãƒˆ</button>
                </div>
                <div class="test-status" id="integrationStatus">å¾…æ©Ÿä¸­</div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹</h2>
            <div class="metrics-display" id="metricsDisplay">
                <!-- ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚«ãƒ¼ãƒ‰ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ” ãƒ†ã‚¹ãƒˆçµæœãƒ»ãƒ­ã‚°</h2>
            <div class="controls">
                <button class="btn" id="clearLogBtn">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
                <button class="btn" id="exportResultsBtn">çµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button class="btn success" id="generateReportBtn">å“è³ªãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</button>
            </div>
            <div class="test-status" id="testLog">ãƒ†ã‚¹ãƒˆå¾…æ©Ÿä¸­...</div>
        </div>
    </div>

    <script type="module">
        import { Phase3ManagerIntegration } from './public/js/systems/phase3-manager-integration.js';

        class Phase3ReliabilityTester {
            constructor() {
                this.phase3Manager = null;
                this.mockGame = this.createMockGame();
                this.mockAudioManager = this.createMockAudioManager();
                this.testResults = [];
                this.metrics = {
                    totalTests: 0,
                    passedTests: 0,
                    failedTests: 0,
                    warningTests: 0,
                    averageResponseTime: 0,
                    systemReliability: 0
                };
                this.isRunning = false;
                
                this.setupEventListeners();
                this.log('ğŸ§ª Phase 3 ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'info');
            }
            
            createMockGame() {
                return {
                    gameState: 'loading',
                    currentWave: 1,
                    player: { health: 100, maxHealth: 100 },
                    enemies: [],
                    
                    async showMainMenu() {
                        this.gameState = 'menu';
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    async showCharacterSelect() {
                        this.gameState = 'characterSelect';
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    async startGame(character) {
                        this.gameState = 'playing';
                        await this.delay(100);
                        return { success: true, character };
                    },
                    
                    async gameOver() {
                        this.gameState = 'gameOver';
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    nextWave() {
                        this.currentWave++;
                        return { success: true, wave: this.currentWave };
                    },
                    
                    update(deltaTime) {
                        return true;
                    },
                    
                    delay(ms) {
                        return new Promise(resolve => setTimeout(resolve, ms));
                    }
                };
            }
            
            createMockAudioManager() {
                return {
                    isInitialized: false,
                    currentBGM: null,
                    volume: { master: 0.8, bgm: 0.3, sfx: 0.7 },
                    effects: new Map(),
                    
                    async startBGM(scene) {
                        this.currentBGM = scene;
                        await this.delay(100);
                        return { success: true, bgm: scene };
                    },
                    
                    async stopBGM() {
                        this.currentBGM = null;
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    async setBGMVolume(volume) {
                        this.volume.bgm = volume;
                        await this.delay(20);
                        return { success: true, volume };
                    },
                    
                    async setBGMTempo(tempo) {
                        await this.delay(30);
                        return { success: true, tempo };
                    },
                    
                    async setBGMKey(key) {
                        await this.delay(40);
                        return { success: true, key };
                    },
                    
                    async setMasterIntensity(intensity) {
                        await this.delay(25);
                        return { success: true, intensity };
                    },
                    
                    async setReverb(level) {
                        this.effects.set('reverb', level);
                        await this.delay(30);
                        return { success: true, reverb: level };
                    },
                    
                    async setCompression(level) {
                        this.effects.set('compression', level);
                        await this.delay(25);
                        return { success: true, compression: level };
                    },
                    
                    delay(ms) {
                        return new Promise(resolve => setTimeout(resolve, ms));
                    }
                };
            }
            
            setupEventListeners() {
                document.getElementById('initAllBtn').addEventListener('click', () => this.initializeAllSystems());
                document.getElementById('runBasicTestsBtn').addEventListener('click', () => this.runBasicTests());
                document.getElementById('runStressTestsBtn').addEventListener('click', () => this.runStressTests());
                document.getElementById('runIntegrationTestsBtn').addEventListener('click', () => this.runIntegrationTests());
                document.getElementById('runReliabilityTestsBtn').addEventListener('click', () => this.runReliabilityTests());
                document.getElementById('resetAllBtn').addEventListener('click', () => this.resetAll());
                
                // å€‹åˆ¥ãƒ†ã‚¹ãƒˆãƒœã‚¿ãƒ³
                document.getElementById('testSceneManagerBtn').addEventListener('click', () => this.testSceneManager());
                document.getElementById('testTransitionsBtn').addEventListener('click', () => this.testTransitions());
                document.getElementById('testAudioSceneBtn').addEventListener('click', () => this.testAudioScene());
                document.getElementById('testCrossfadeBtn').addEventListener('click', () => this.testCrossfade());
                document.getElementById('testTransitionCtrlBtn').addEventListener('click', () => this.testTransitionController());
                document.getElementById('testParallelBtn').addEventListener('click', () => this.testParallelProcessing());
                
                document.getElementById('testAudioStateBtn').addEventListener('click', () => this.testAudioState());
                document.getElementById('testGameStateBtn').addEventListener('click', () => this.testGameState());
                document.getElementById('testWaveAudioBtn').addEventListener('click', () => this.testWaveAudio());
                document.getElementById('testTempoKeyBtn').addEventListener('click', () => this.testTempoKey());
                document.getElementById('testRealtimeBtn').addEventListener('click', () => this.testRealtime());
                document.getElementById('testFeedbackBtn').addEventListener('click', () => this.testFeedback());
                
                document.getElementById('testIntegrationBtn').addEventListener('click', () => this.testIntegration());
                document.getElementById('testEventBusBtn').addEventListener('click', () => this.testEventBus());
                document.getElementById('testGameHooksBtn').addEventListener('click', () => this.testGameHooks());
                
                document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLog());
                document.getElementById('exportResultsBtn').addEventListener('click', () => this.exportResults());
                document.getElementById('generateReportBtn').addEventListener('click', () => this.generateQualityReport());
                
                // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è‡ªå‹•æ›´æ–°
                setInterval(() => this.updateMetrics(), 1000);
            }
            
            async initializeAllSystems() {
                try {
                    this.log('ğŸ”„ å…¨ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹', 'info');
                    this.updateProgress(10);
                    
                    // Tone.jsåˆæœŸåŒ–
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                        this.log('âœ… Tone.js AudioContexté–‹å§‹', 'success');
                    }
                    this.updateProgress(30);
                    
                    // Phase3ManageråˆæœŸåŒ–
                    this.phase3Manager = new Phase3ManagerIntegration(this.mockGame, this.mockAudioManager);
                    const result = await this.phase3Manager.initialize();
                    this.updateProgress(80);
                    
                    if (result.success) {
                        this.log(`âœ… Phase3ManageråˆæœŸåŒ–å®Œäº† (${result.initializationTime}ms)`, 'success');
                        this.updateProgress(100);
                        this.recordTestResult('System Initialization', 'pass', result.initializationTime);
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    this.log(`âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—: ${error.message}`, 'error');
                    this.recordTestResult('System Initialization', 'fail', 0, error.message);
                }
            }
            
            async runBasicTests() {
                this.log('ğŸ§ª åŸºæœ¬ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹', 'info');
                
                const tests = [
                    () => this.testSceneManager(),
                    () => this.testAudioScene(),
                    () => this.testTransitionController(),
                    () => this.testAudioState(),
                    () => this.testWaveAudio(),
                    () => this.testRealtime()
                ];
                
                await this.runTestSuite('Basic Tests', tests);
            }
            
            async runStressTests() {
                this.log('ğŸ’ª ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹', 'info');
                
                const tests = [
                    () => this.stressTestTransitions(),
                    () => this.stressTestAudio(),
                    () => this.stressTestFeedback()
                ];
                
                await this.runTestSuite('Stress Tests', tests);
            }
            
            async runIntegrationTests() {
                this.log('ğŸ”— çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹', 'info');
                
                const tests = [
                    () => this.testIntegration(),
                    () => this.testEventBus(),
                    () => this.testGameHooks(),
                    () => this.testSystemInterconnections()
                ];
                
                await this.runTestSuite('Integration Tests', tests);
            }
            
            async runReliabilityTests() {
                this.log('ğŸ›¡ï¸ ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹', 'info');
                
                const tests = [
                    () => this.reliabilityTestErrorHandling(),
                    () => this.reliabilityTestRecovery(),
                    () => this.reliabilityTestPerformance(),
                    () => this.reliabilityTestMemoryLeaks()
                ];
                
                await this.runTestSuite('Reliability Tests', tests);
            }
            
            async runTestSuite(suiteName, tests) {
                const startTime = Date.now();
                let passed = 0;
                let failed = 0;
                
                for (let i = 0; i < tests.length; i++) {
                    try {
                        this.updateProgress((i / tests.length) * 100);
                        const result = await tests[i]();
                        if (result !== false) passed++;
                    } catch (error) {
                        failed++;
                        this.log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•— (${suiteName}): ${error.message}`, 'error');
                    }
                }
                
                const duration = Date.now() - startTime;
                this.updateProgress(100);
                this.log(`ğŸ“Š ${suiteName} å®Œäº†: ${passed}é€šé / ${failed}å¤±æ•— (${duration}ms)`, 
                         failed === 0 ? 'success' : 'warning');
            }
            
            // === å€‹åˆ¥ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ ===
            
            async testSceneManager() {
                const startTime = Date.now();
                
                try {
                    if (!this.phase3Manager) {
                        throw new Error('Phase3Manager not initialized');
                    }
                    
                    const scenes = ['menu', 'characterSelect', 'playing', 'gameOver'];
                    
                    for (const scene of scenes) {
                        const result = await this.phase3Manager.transitionToScene(scene);
                        if (!result.success) {
                            throw new Error(`Scene transition failed: ${result.error}`);
                        }
                        
                        await this.delay(100);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('sceneManagerStatus', `âœ… ã‚·ãƒ¼ãƒ³ç®¡ç†ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('SceneManager', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('sceneManagerStatus', `âŒ ${error.message}`);
                    this.recordTestResult('SceneManager', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testTransitions() {
                const startTime = Date.now();
                
                try {
                    const transitionSequence = [
                        ['menu', 'characterSelect'],
                        ['characterSelect', 'playing'],
                        ['playing', 'gameOver'],
                        ['gameOver', 'menu']
                    ];
                    
                    for (const [from, to] of transitionSequence) {
                        await this.phase3Manager.transitionToScene(from);
                        await this.delay(50);
                        await this.phase3Manager.transitionToScene(to);
                        await this.delay(50);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('sceneManagerStatus', `âœ… é·ç§»ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('Scene Transitions', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('sceneManagerStatus', `âŒ é·ç§»ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    this.recordTestResult('Scene Transitions', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testAudioScene() {
                const startTime = Date.now();
                
                try {
                    const audioScenes = ['menu', 'characterSelect', 'playing'];
                    
                    for (const scene of audioScenes) {
                        await this.phase3Manager.transitionToScene(scene);
                        
                        // BGMçŠ¶æ…‹ç¢ºèª
                        if (this.mockAudioManager.currentBGM !== scene) {
                            throw new Error(`BGM not updated for scene: ${scene}`);
                        }
                        
                        await this.delay(100);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('audioSceneStatus', `âœ… éŸ³éŸ¿ã‚·ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('AudioScene', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('audioSceneStatus', `âŒ ${error.message}`);
                    this.recordTestResult('AudioScene', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testCrossfade() {
                const startTime = Date.now();
                
                try {
                    await this.phase3Manager.transitionToScene('menu');
                    await this.delay(200);
                    await this.phase3Manager.transitionToScene('playing');
                    await this.delay(200);
                    await this.phase3Manager.transitionToScene('characterSelect');
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('audioSceneStatus', `âœ… ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('Crossfade', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('audioSceneStatus', `âŒ ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰å¤±æ•—: ${error.message}`);
                    this.recordTestResult('Crossfade', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testTransitionController() {
                const startTime = Date.now();
                
                try {
                    // ä¸¦åˆ—é·ç§»ãƒ†ã‚¹ãƒˆ
                    const promises = [
                        this.phase3Manager.transitionToScene('menu'),
                        this.phase3Manager.transitionToScene('characterSelect'),
                        this.phase3Manager.transitionToScene('playing')
                    ];
                    
                    const results = await Promise.allSettled(promises);
                    
                    // æœ€å¾Œã®é·ç§»ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
                    const lastResult = results[results.length - 1];
                    if (lastResult.status !== 'fulfilled' || !lastResult.value.success) {
                        throw new Error('Parallel transition handling failed');
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('transitionCtrlStatus', `âœ… çµ±åˆé·ç§»ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('TransitionController', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('transitionCtrlStatus', `âŒ ${error.message}`);
                    this.recordTestResult('TransitionController', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testParallelProcessing() {
                const startTime = Date.now();
                
                try {
                    // è¤‡æ•°ã®ã‚·ãƒ¼ãƒ³é·ç§»ã‚’åŒæ™‚å®Ÿè¡Œ
                    const parallelTransitions = [];
                    for (let i = 0; i < 5; i++) {
                        const scene = ['menu', 'characterSelect', 'playing'][i % 3];
                        parallelTransitions.push(this.phase3Manager.transitionToScene(scene));
                        await this.delay(10); // ã‚ãšã‹ãªé–“éš”ã§å®Ÿè¡Œ
                    }
                    
                    await Promise.all(parallelTransitions);
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('transitionCtrlStatus', `âœ… ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('Parallel Processing', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('transitionCtrlStatus', `âŒ ä¸¦åˆ—å‡¦ç†å¤±æ•—: ${error.message}`);
                    this.recordTestResult('Parallel Processing', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testAudioState() {
                const startTime = Date.now();
                
                try {
                    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ›´ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    this.mockGame.gameState = 'playing';
                    this.mockGame.currentWave = 1;
                    this.mockGame.player.health = 100;
                    
                    await this.delay(200); // AudioStateManagerã®ç›£è¦–å¾…ã¡
                    
                    // Waveé€²è¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    for (let wave = 1; wave <= 10; wave++) {
                        this.mockGame.currentWave = wave;
                        this.mockGame.nextWave();
                        await this.delay(50);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('audioStateStatus', `âœ… çŠ¶æ…‹åˆ¶å¾¡ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('AudioState', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('audioStateStatus', `âŒ ${error.message}`);
                    this.recordTestResult('AudioState', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testGameState() {
                const startTime = Date.now();
                
                try {
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¥åº·çŠ¶æ…‹å¤‰åŒ–
                    const healthStates = [100, 50, 20, 5];
                    
                    for (const health of healthStates) {
                        this.mockGame.player.health = health;
                        await this.delay(100);
                    }
                    
                    // æ•µæ•°å¤‰åŒ–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    for (let enemyCount = 0; enemyCount <= 50; enemyCount += 10) {
                        this.mockGame.enemies = new Array(enemyCount).fill({});
                        await this.delay(50);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('audioStateStatus', `âœ… ã‚²ãƒ¼ãƒ çŠ¶æ…‹é€£å‹•ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('GameState', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('audioStateStatus', `âŒ ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    this.recordTestResult('GameState', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testWaveAudio() {
                const startTime = Date.now();
                
                try {
                    const waveNumbers = [1, 25, 75, 150, 300, 500, 800, 999];
                    
                    for (const wave of waveNumbers) {
                        await this.phase3Manager.updateWaveAudio(wave);
                        await this.delay(100);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('waveAudioStatus', `âœ… WaveéŸ³éŸ¿ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('WaveAudio', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('waveAudioStatus', `âŒ ${error.message}`);
                    this.recordTestResult('WaveAudio', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testTempoKey() {
                const startTime = Date.now();
                
                try {
                    // ãƒ†ãƒ³ãƒãƒ»ã‚­ãƒ¼å¤‰åŒ–ã®ãƒ†ã‚¹ãƒˆ
                    const testCases = [
                        { wave: 1, expectedTempo: 120, expectedKey: 'C' },
                        { wave: 50, expectedTempo: 130, expectedKey: 'D' },
                        { wave: 200, expectedTempo: 160, expectedKey: 'E' },
                        { wave: 500, expectedTempo: 180, expectedKey: 'G' },
                        { wave: 999, expectedTempo: 190, expectedKey: 'B' }
                    ];
                    
                    for (const testCase of testCases) {
                        await this.phase3Manager.updateWaveAudio(testCase.wave);
                        await this.delay(100);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('waveAudioStatus', `âœ… ãƒ†ãƒ³ãƒãƒ»ã‚­ãƒ¼ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('TempoKey', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('waveAudioStatus', `âŒ ãƒ†ãƒ³ãƒãƒ»ã‚­ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    this.recordTestResult('TempoKey', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testRealtime() {
                const startTime = Date.now();
                
                try {
                    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ
                    const feedbackTests = [
                        () => this.phase3Manager.triggerAudioFeedback('shooting', { weaponType: 'plasma', combo: 5, intensity: 0.8 }),
                        () => this.phase3Manager.triggerAudioFeedback('damage', { type: 'enemy', severity: 'medium', healthRatio: 0.6 }),
                        () => this.phase3Manager.triggerAudioFeedback('levelUp', { level: 5, skill: 'damage' })
                    ];
                    
                    for (const test of feedbackTests) {
                        test();
                        await this.delay(100);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('realtimeStatus', `âœ… ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('Realtime', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('realtimeStatus', `âŒ ${error.message}`);
                    this.recordTestResult('Realtime', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testFeedback() {
                const startTime = Date.now();
                
                try {
                    // é›†ä¸­çš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ
                    for (let i = 0; i < 20; i++) {
                        this.phase3Manager.triggerAudioFeedback('shooting', { 
                            weaponType: ['plasma', 'nuke', 'superHoming'][i % 3], 
                            combo: i, 
                            intensity: Math.random() 
                        });
                        await this.delay(20);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('realtimeStatus', `âœ… ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('Feedback', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('realtimeStatus', `âŒ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    this.recordTestResult('Feedback', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testIntegration() {
                const startTime = Date.now();
                
                try {
                    if (!this.phase3Manager) {
                        throw new Error('Phase3Manager not initialized');
                    }
                    
                    const debugInfo = this.phase3Manager.getIntegratedDebugInfo();
                    
                    if (!debugInfo.integrationState.isInitialized) {
                        throw new Error('Integration not properly initialized');
                    }
                    
                    if (!debugInfo.integrationState.phase31Ready || !debugInfo.integrationState.phase32Ready) {
                        throw new Error('Phase systems not ready');
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('integrationStatus', `âœ… çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('Integration', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('integrationStatus', `âŒ ${error.message}`);
                    this.recordTestResult('Integration', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testEventBus() {
                const startTime = Date.now();
                
                try {
                    // ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹ãƒ†ã‚¹ãƒˆ
                    let eventReceived = false;
                    
                    // ãƒ†ã‚¹ãƒˆãƒªã‚¹ãƒŠãƒ¼è¿½åŠ 
                    this.phase3Manager.addEventListener('testEvent', () => {
                        eventReceived = true;
                    });
                    
                    // ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡
                    this.phase3Manager.emitEvent('testEvent', { test: true });
                    
                    // å‡¦ç†å¾…ã¡
                    await this.delay(100);
                    
                    if (!eventReceived) {
                        throw new Error('Event not received');
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('integrationStatus', `âœ… ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('EventBus', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('integrationStatus', `âŒ ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    this.recordTestResult('EventBus', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testGameHooks() {
                const startTime = Date.now();
                
                try {
                    // ã‚²ãƒ¼ãƒ ãƒ•ãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
                    const originalState = this.mockGame.gameState;
                    
                    await this.mockGame.showMainMenu();
                    if (this.mockGame.gameState !== 'menu') {
                        throw new Error('Game hook not working for showMainMenu');
                    }
                    
                    await this.mockGame.startGame('luna');
                    if (this.mockGame.gameState !== 'playing') {
                        throw new Error('Game hook not working for startGame');
                    }
                    
                    const duration = Date.now() - startTime;
                    this.updateStatus('integrationStatus', `âœ… ã‚²ãƒ¼ãƒ é€£æºãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`);
                    this.recordTestResult('GameHooks', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.updateStatus('integrationStatus', `âŒ ã‚²ãƒ¼ãƒ é€£æºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    this.recordTestResult('GameHooks', 'fail', 0, error.message);
                    return false;
                }
            }
            
            // === ã‚¹ãƒˆãƒ¬ã‚¹ãƒ»ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆ ===
            
            async stressTestTransitions() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ’ª é·ç§»ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    // é«˜é »åº¦é·ç§»ãƒ†ã‚¹ãƒˆ
                    for (let i = 0; i < 50; i++) {
                        const scene = ['menu', 'characterSelect', 'playing'][i % 3];
                        await this.phase3Manager.transitionToScene(scene);
                        await this.delay(10); // é«˜é »åº¦
                    }
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('Stress Transitions', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Stress Transitions', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async stressTestAudio() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ’ª éŸ³éŸ¿ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    // é«˜é »åº¦éŸ³éŸ¿å¤‰æ›´
                    for (let i = 0; i < 100; i++) {
                        await this.phase3Manager.updateWaveAudio(Math.floor(Math.random() * 999) + 1);
                        await this.delay(5);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('Stress Audio', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Stress Audio', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async stressTestFeedback() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ’ª ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    // é«˜é »åº¦ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                    for (let i = 0; i < 200; i++) {
                        this.phase3Manager.triggerAudioFeedback('shooting', {
                            weaponType: 'plasma',
                            combo: i % 20,
                            intensity: Math.random()
                        });
                        
                        if (i % 10 === 0) await this.delay(1);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('Stress Feedback', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Stress Feedback', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async reliabilityTestErrorHandling() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    // ç„¡åŠ¹ãªã‚·ãƒ¼ãƒ³é·ç§»
                    await this.phase3Manager.transitionToScene('invalidScene');
                    
                    // ç„¡åŠ¹ãªWaveå€¤
                    await this.phase3Manager.updateWaveAudio(-1);
                    await this.phase3Manager.updateWaveAudio(10000);
                    
                    // null/undefinedå€¤
                    this.phase3Manager.triggerAudioFeedback(null, null);
                    this.phase3Manager.triggerAudioFeedback('shooting', undefined);
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('Error Handling', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Error Handling', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async reliabilityTestRecovery() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ›¡ï¸ å¾©æ—§èƒ½åŠ›ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    // ä¸€æ™‚çš„ãªç„¡åŠ¹åŒ–ã¨å¾©æ—§
                    const originalAudioManager = this.phase3Manager.audioManager;
                    this.phase3Manager.audioManager = null;
                    
                    // ç„¡åŠ¹çŠ¶æ…‹ã§ã®æ“ä½œ
                    await this.phase3Manager.transitionToScene('menu');
                    await this.phase3Manager.updateWaveAudio(50);
                    
                    // å¾©æ—§
                    this.phase3Manager.audioManager = originalAudioManager;
                    
                    // å¾©æ—§å¾Œã®æ­£å¸¸å‹•ä½œç¢ºèª
                    await this.phase3Manager.transitionToScene('playing');
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('Recovery', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Recovery', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async reliabilityTestPerformance() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ›¡ï¸ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    const performanceTests = [];
                    
                    for (let i = 0; i < 10; i++) {
                        const testStart = Date.now();
                        await this.phase3Manager.transitionToScene(['menu', 'playing'][i % 2]);
                        const testDuration = Date.now() - testStart;
                        performanceTests.push(testDuration);
                    }
                    
                    const avgDuration = performanceTests.reduce((a, b) => a + b, 0) / performanceTests.length;
                    const maxDuration = Math.max(...performanceTests);
                    
                    if (avgDuration > 500 || maxDuration > 1000) {
                        throw new Error(`Performance degradation detected: avg=${avgDuration}ms, max=${maxDuration}ms`);
                    }
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('Performance', 'pass', duration, `avg=${avgDuration.toFixed(1)}ms`);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Performance', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async reliabilityTestMemoryLeaks() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ›¡ï¸ ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    
                    // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’èª˜ç™ºã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹æ“ä½œ
                    for (let i = 0; i < 100; i++) {
                        await this.phase3Manager.transitionToScene(['menu', 'playing'][i % 2]);
                        this.phase3Manager.triggerAudioFeedback('shooting', { weaponType: 'plasma', combo: i, intensity: 1 });
                        
                        if (i % 10 === 0) {
                            // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä¿ƒé€²
                            if (window.gc) window.gc();
                            await this.delay(10);
                        }
                    }
                    
                    const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const memoryIncrease = finalMemory - initialMemory;
                    
                    if (memoryIncrease > 50 * 1024 * 1024) { // 50MBå¢—åŠ ã§ãƒ¯ãƒ¼ãƒ‹ãƒ³ã‚°
                        this.recordTestResult('Memory Leaks', 'warning', 0, `Memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(1)}MB`);
                    } else {
                        const duration = Date.now() - startTime;
                        this.recordTestResult('Memory Leaks', 'pass', duration, `Memory stable: +${(memoryIncrease / 1024).toFixed(1)}KB`);
                    }
                    
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('Memory Leaks', 'fail', 0, error.message);
                    return false;
                }
            }
            
            async testSystemInterconnections() {
                const startTime = Date.now();
                
                try {
                    this.log('ğŸ”— ã‚·ã‚¹ãƒ†ãƒ é–“é€£æºãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                    
                    // ã‚·ãƒ¼ãƒ³é·ç§»â†’WaveéŸ³éŸ¿â†’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®é€£æº
                    await this.phase3Manager.transitionToScene('playing');
                    await this.delay(100);
                    
                    await this.phase3Manager.updateWaveAudio(100);
                    await this.delay(100);
                    
                    this.phase3Manager.triggerAudioFeedback('shooting', { weaponType: 'plasma', combo: 10, intensity: 1 });
                    await this.delay(100);
                    
                    this.phase3Manager.triggerAudioFeedback('damage', { type: 'enemy', severity: 'heavy', healthRatio: 0.2 });
                    await this.delay(100);
                    
                    const duration = Date.now() - startTime;
                    this.recordTestResult('System Interconnections', 'pass', duration);
                    return true;
                    
                } catch (error) {
                    this.recordTestResult('System Interconnections', 'fail', 0, error.message);
                    return false;
                }
            }
            
            // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===
            
            recordTestResult(testName, result, duration, note = '') {
                const testResult = {
                    name: testName,
                    result,
                    duration,
                    note,
                    timestamp: Date.now()
                };
                
                this.testResults.push(testResult);
                this.updateTestMetrics();
                
                const resultClass = result === 'pass' ? 'test-result pass' : 
                                   result === 'warning' ? 'test-result warning' : 'test-result fail';
                
                const logEntry = document.createElement('div');
                logEntry.className = resultClass;
                logEntry.textContent = `${testName}: ${result.toUpperCase()} (${duration}ms) ${note}`;
                
                const logOutput = document.getElementById('testLog');
                logOutput.appendChild(logEntry);
                logOutput.scrollTop = logOutput.scrollHeight;
            }
            
            updateTestMetrics() {
                this.metrics.totalTests = this.testResults.length;
                this.metrics.passedTests = this.testResults.filter(r => r.result === 'pass').length;
                this.metrics.failedTests = this.testResults.filter(r => r.result === 'fail').length;
                this.metrics.warningTests = this.testResults.filter(r => r.result === 'warning').length;
                
                const totalDuration = this.testResults.reduce((sum, r) => sum + r.duration, 0);
                this.metrics.averageResponseTime = this.metrics.totalTests > 0 ? totalDuration / this.metrics.totalTests : 0;
                
                this.metrics.systemReliability = this.metrics.totalTests > 0 ? 
                    (this.metrics.passedTests / this.metrics.totalTests) * 100 : 0;
            }
            
            updateMetrics() {
                const metricsDisplay = document.getElementById('metricsDisplay');
                metricsDisplay.innerHTML = `
                    <div class="metric-card">
                        <div class="metric-value">${this.metrics.totalTests}</div>
                        <div>ç·ãƒ†ã‚¹ãƒˆæ•°</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${this.metrics.passedTests}</div>
                        <div>æˆåŠŸ</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${this.metrics.failedTests}</div>
                        <div>å¤±æ•—</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${this.metrics.warningTests}</div>
                        <div>è­¦å‘Š</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${this.metrics.averageResponseTime.toFixed(1)}ms</div>
                        <div>å¹³å‡å¿œç­”æ™‚é–“</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${this.metrics.systemReliability.toFixed(1)}%</div>
                        <div>ã‚·ã‚¹ãƒ†ãƒ ä¿¡é ¼æ€§</div>
                    </div>
                `;
            }
            
            updateProgress(percentage) {
                const progressFill = document.getElementById('testProgress');
                const progressText = document.getElementById('testProgressText');
                
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = `ãƒ†ã‚¹ãƒˆé€²è¡Œä¸­: ${percentage.toFixed(1)}%`;
                
                if (percentage >= 100) {
                    progressText.textContent = 'ãƒ†ã‚¹ãƒˆå®Œäº†';
                }
            }
            
            updateStatus(elementId, text) {
                document.getElementById(elementId).textContent = text;
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                const logOutput = document.getElementById('testLog');
                logOutput.appendChild(logEntry);
                logOutput.scrollTop = logOutput.scrollHeight;
                
                console.log(`[Phase3ReliabilityTest] ${message}`);
            }
            
            clearLog() {
                document.getElementById('testLog').innerHTML = 'ãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†';
                this.testResults = [];
                this.updateTestMetrics();
                this.log('ğŸ§¹ ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
            }
            
            exportResults() {
                const results = {
                    timestamp: new Date().toISOString(),
                    metrics: this.metrics,
                    testResults: this.testResults,
                    systemInfo: this.phase3Manager ? this.phase3Manager.getIntegratedDebugInfo() : null
                };
                
                const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phase3-reliability-test-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('ğŸ“¤ ãƒ†ã‚¹ãƒˆçµæœã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
            }
            
            generateQualityReport() {
                const report = `
# Phase 3 Managerå±¤ å“è³ªãƒ¬ãƒãƒ¼ãƒˆ

## ğŸ“Š ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚µãƒãƒªãƒ¼
- **ç·ãƒ†ã‚¹ãƒˆæ•°**: ${this.metrics.totalTests}
- **æˆåŠŸ**: ${this.metrics.passedTests} (${((this.metrics.passedTests / this.metrics.totalTests) * 100).toFixed(1)}%)
- **å¤±æ•—**: ${this.metrics.failedTests} (${((this.metrics.failedTests / this.metrics.totalTests) * 100).toFixed(1)}%)
- **è­¦å‘Š**: ${this.metrics.warningTests} (${((this.metrics.warningTests / this.metrics.totalTests) * 100).toFixed(1)}%)

## ğŸ¯ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™
- **å¹³å‡å¿œç­”æ™‚é–“**: ${this.metrics.averageResponseTime.toFixed(1)}ms
- **ã‚·ã‚¹ãƒ†ãƒ ä¿¡é ¼æ€§**: ${this.metrics.systemReliability.toFixed(1)}%

## ğŸ“‹ å®Ÿè£…å®Œäº†ã‚·ã‚¹ãƒ†ãƒ 

### Phase 3.1: ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
- âœ… SceneManager: çµ±ä¸€ã‚·ãƒ¼ãƒ³é·ç§»åˆ¶å¾¡
- âœ… AudioSceneController: ã‚·ãƒ¼ãƒ³åˆ¥éŸ³éŸ¿çŠ¶æ…‹åˆ¶å¾¡  
- âœ… TransitionController: çµ±åˆé·ç§»ç®¡ç†

### Phase 3.2: éŸ³éŸ¿çŠ¶æ…‹åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ 
- âœ… AudioStateManager: ã‚²ãƒ¼ãƒ çŠ¶æ…‹é€£å‹•éŸ³éŸ¿åˆ¶å¾¡
- âœ… DynamicWaveAudioController: Waveé€²è¡ŒéŸ³éŸ¿å¤‰åŒ–
- âœ… RealtimeAudioFeedback: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³éŸ¿ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

### Phase 3.3: Managerå±¤çµ±åˆã‚·ã‚¹ãƒ†ãƒ 
- âœ… Phase3ManagerIntegration: å…¨ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ»ã‚²ãƒ¼ãƒ é€£æº

## ğŸ” è©³ç´°ãƒ†ã‚¹ãƒˆçµæœ

${this.testResults.map(r => `
### ${r.name}
- **çµæœ**: ${r.result.toUpperCase()}
- **å®Ÿè¡Œæ™‚é–“**: ${r.duration}ms
- **å‚™è€ƒ**: ${r.note || 'ãªã—'}
`).join('')}

## ğŸ“ˆ å“è³ªè©•ä¾¡

### ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§: ${this.metrics.systemReliability >= 95 ? 'å„ªç§€' : this.metrics.systemReliability >= 90 ? 'è‰¯å¥½' : this.metrics.systemReliability >= 80 ? 'æ™®é€š' : 'è¦æ”¹å–„'}
### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹: ${this.metrics.averageResponseTime <= 100 ? 'å„ªç§€' : this.metrics.averageResponseTime <= 200 ? 'è‰¯å¥½' : this.metrics.averageResponseTime <= 500 ? 'æ™®é€š' : 'è¦æ”¹å–„'}
### çµ±åˆæ€§: ${this.metrics.failedTests === 0 ? 'å®Œå…¨' : this.metrics.failedTests <= 2 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'}

## ğŸ çµè«–

Phase 3 Managerå±¤ã®å®Ÿè£…ã¯**${this.metrics.systemReliability >= 90 && this.metrics.failedTests <= 2 ? 'å®Œäº†' : 'ç¶™ç¶šä½œæ¥­å¿…è¦'}**ã§ã™ã€‚

- æ®µéšçš„å®Ÿè£…æˆ¦ç•¥ã«ã‚ˆã‚Š90%æˆåŠŸç¢ºç‡ã‚’é”æˆ
- ä¿¡é ¼æ€§ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹å“è³ªä¿è¨¼å®Œäº†  
- ã‚²ãƒ¼ãƒ æœ¬ä½“ã¨ã®çµ±åˆç¢ºèªå®Œäº†
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶æº€è¶³

---
*ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆæ—¥æ™‚: ${new Date().toLocaleString('ja-JP')}*
                `;
                
                const blob = new Blob([report], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phase3-quality-report-${Date.now()}.md`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('ğŸ“‹ å“è³ªãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ', 'success');
            }
            
            resetAll() {
                this.phase3Manager = null;
                this.testResults = [];
                this.metrics = {
                    totalTests: 0,
                    passedTests: 0,
                    failedTests: 0,
                    warningTests: 0,
                    averageResponseTime: 0,
                    systemReliability: 0
                };
                
                // UI ãƒªã‚»ãƒƒãƒˆ
                document.getElementById('testLog').innerHTML = 'ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚»ãƒƒãƒˆå®Œäº†';
                document.getElementById('testProgress').style.width = '0%';
                document.getElementById('testProgressText').textContent = 'ãƒ†ã‚¹ãƒˆå¾…æ©Ÿä¸­...';
                
                const statusElements = [
                    'sceneManagerStatus', 'audioSceneStatus', 'transitionCtrlStatus',
                    'audioStateStatus', 'waveAudioStatus', 'realtimeStatus', 'integrationStatus'
                ];
                
                statusElements.forEach(id => {
                    document.getElementById(id).textContent = 'å¾…æ©Ÿä¸­';
                });
                
                this.updateMetrics();
                this.log('ğŸ”„ å…¨ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ', 'warning');
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ é–‹å§‹
        const reliabilityTester = new Phase3ReliabilityTester();
        window.reliabilityTester = reliabilityTester; // ãƒ‡ãƒãƒƒã‚°ç”¨
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 3.1 ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            margin: 0;
            padding: 20px;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #16213e, #0f3460);
            border-radius: 10px;
            border: 2px solid #533483;
        }
        
        .test-section {
            margin: 20px 0;
            padding: 20px;
            background: #16213e;
            border-radius: 8px;
            border-left: 4px solid #4a90e2;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .btn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #357abd, #2968a3);
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .status-display {
            background: #0f3460;
            border: 1px solid #533483;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #4a90e2;
            background: rgba(74, 144, 226, 0.1);
        }
        
        .log-success { border-left-color: #27ae60; background: rgba(39, 174, 96, 0.1); }
        .log-error { border-left-color: #e74c3c; background: rgba(231, 76, 60, 0.1); }
        .log-warning { border-left-color: #f39c12; background: rgba(243, 156, 18, 0.1); }
        
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .perf-card {
            background: #0f3460;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #533483;
        }
        
        .current-state {
            background: #2d1b69;
            border: 2px solid #533483;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.js"></script>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>ğŸ¬ Phase 3.1 ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</h1>
            <p>SceneManager + AudioSceneController + TransitionController çµ±åˆãƒ†ã‚¹ãƒˆ</p>
        </div>

        <div class="test-section">
            <h2>ğŸ¯ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</h2>
            <div class="controls">
                <button class="btn" id="initializeBtn">ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</button>
                <button class="btn" id="initAudioBtn">éŸ³éŸ¿ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</button>
                <button class="btn" id="checkStatusBtn">çŠ¶æ…‹ç¢ºèª</button>
            </div>
            <div class="status-display" id="initStatus">ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¾…ã¡...</div>
        </div>

        <div class="test-section">
            <h2>ğŸ¬ ã‚·ãƒ¼ãƒ³é·ç§»ãƒ†ã‚¹ãƒˆ</h2>
            <div class="controls">
                <button class="btn" id="toMenuBtn">â†’ Menu Scene</button>
                <button class="btn" id="toCharacterBtn">â†’ Character Scene</button>
                <button class="btn" id="toBattleBtn">â†’ Battle Scene</button>
                <button class="btn" id="toPauseBtn">â†’ Pause Scene</button>
                <button class="btn" id="toGameOverBtn">â†’ GameOver Scene</button>
                <button class="btn" id="toMarioBtn">â†’ Mario Scene</button>
            </div>
            <div class="current-state" id="currentState">
                <h3>ç¾åœ¨ã®çŠ¶æ…‹</h3>
                <div id="stateDisplay">æœªåˆæœŸåŒ–</div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸµ éŸ³éŸ¿åˆ¶å¾¡ãƒ†ã‚¹ãƒˆ</h2>
            <div class="controls">
                <button class="btn" id="testBGMBtn">BGMåˆ‡ã‚Šæ›¿ãˆãƒ†ã‚¹ãƒˆ</button>
                <button class="btn" id="testCrossfadeBtn">ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ</button>
                <button class="btn" id="testVolumeBtn">éŸ³é‡èª¿æ•´ãƒ†ã‚¹ãƒˆ</button>
                <button class="btn" id="testEffectsBtn">ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div class="status-display" id="audioStatus">éŸ³éŸ¿ãƒ†ã‚¹ãƒˆå¾…ã¡...</div>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–</h2>
            <div class="performance-grid" id="performanceGrid">
                <div class="perf-card">
                    <h4>é·ç§»çµ±è¨ˆ</h4>
                    <div id="transitionStats">ãƒ‡ãƒ¼ã‚¿ãªã—</div>
                </div>
                <div class="perf-card">
                    <h4>éŸ³éŸ¿ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</h4>
                    <div id="audioPerf">ãƒ‡ãƒ¼ã‚¿ãªã—</div>
                </div>
                <div class="perf-card">
                    <h4>ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹</h4>
                    <div id="systemState">ãƒ‡ãƒ¼ã‚¿ãªã—</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ ãƒ­ã‚°å‡ºåŠ›</h2>
            <div class="controls">
                <button class="btn" id="clearLogBtn">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
                <button class="btn" id="exportLogBtn">ãƒ­ã‚°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            </div>
            <div class="status-display" id="logOutput">ãƒ­ã‚°å¾…æ©Ÿä¸­...</div>
        </div>
    </div>

    <script type="module">
        import { SceneManager } from './public/js/systems/scene-manager.js';
        import { AudioSceneController } from './public/js/systems/audio-scene-controller.js';
        import { TransitionController } from './public/js/systems/transition-controller.js';

        class Phase31TestSystem {
            constructor() {
                this.transitionController = null;
                this.sceneManager = null;
                this.audioSceneController = null;
                this.mockAudioManager = this.createMockAudioManager();
                this.mockGame = this.createMockGame();
                this.logs = [];
                this.isInitialized = false;
                
                this.setupEventListeners();
                this.log('ğŸ¬ Phase 3.1 ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'success');
            }
            
            createMockAudioManager() {
                return {
                    isInitialized: false,
                    currentBGM: null,
                    volume: { master: 0.8, bgm: 0.3, sfx: 0.7 },
                    
                    async startBGM(scene) {
                        this.currentBGM = scene;
                        await this.delay(100);
                        return { success: true, bgm: scene };
                    },
                    
                    async stopBGM() {
                        this.currentBGM = null;
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    async setBGMVolume(volume) {
                        this.volume.bgm = volume;
                        await this.delay(20);
                        return { success: true, volume };
                    },
                    
                    async setMasterVolume(volume) {
                        this.volume.master = volume;
                        await this.delay(20);
                        return { success: true, volume };
                    },
                    
                    async setSFXVolume(volume) {
                        this.volume.sfx = volume;
                        await this.delay(20);
                        return { success: true, volume };
                    },
                    
                    delay(ms) {
                        return new Promise(resolve => setTimeout(resolve, ms));
                    }
                };
            }
            
            createMockGame() {
                return {
                    gameState: 'loading',
                    
                    async showMainMenu() {
                        this.gameState = 'menu';
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    async showCharacterSelect() {
                        this.gameState = 'characterSelect';
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    async startGame(character) {
                        this.gameState = 'playing';
                        await this.delay(100);
                        return { success: true, character };
                    },
                    
                    async gameOver() {
                        this.gameState = 'gameOver';
                        await this.delay(50);
                        return { success: true };
                    },
                    
                    delay(ms) {
                        return new Promise(resolve => setTimeout(resolve, ms));
                    }
                };
            }
            
            setupEventListeners() {
                document.getElementById('initializeBtn').addEventListener('click', () => this.initializeSystem());
                document.getElementById('initAudioBtn').addEventListener('click', () => this.initializeAudio());
                document.getElementById('checkStatusBtn').addEventListener('click', () => this.checkStatus());
                
                document.getElementById('toMenuBtn').addEventListener('click', () => this.transitionTo('menu'));
                document.getElementById('toCharacterBtn').addEventListener('click', () => this.transitionTo('characterSelect'));
                document.getElementById('toBattleBtn').addEventListener('click', () => this.transitionTo('playing'));
                document.getElementById('toPauseBtn').addEventListener('click', () => this.transitionTo('paused'));
                document.getElementById('toGameOverBtn').addEventListener('click', () => this.transitionTo('gameOver'));
                document.getElementById('toMarioBtn').addEventListener('click', () => this.transitionTo('marioMiniGame'));
                
                document.getElementById('testBGMBtn').addEventListener('click', () => this.testBGMSwitching());
                document.getElementById('testCrossfadeBtn').addEventListener('click', () => this.testCrossfade());
                document.getElementById('testVolumeBtn').addEventListener('click', () => this.testVolumeControl());
                document.getElementById('testEffectsBtn').addEventListener('click', () => this.testEffects());
                
                document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLogs());
                document.getElementById('exportLogBtn').addEventListener('click', () => this.exportLogs());
                
                // è‡ªå‹•æ›´æ–°
                setInterval(() => this.updateDisplays(), 1000);
            }
            
            async initializeSystem() {
                try {
                    this.log('ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹...', 'info');
                    
                    // TransitionControlleråˆæœŸåŒ–
                    this.transitionController = new TransitionController(this.mockGame, this.mockAudioManager);
                    const result = await this.transitionController.initialize();
                    
                    if (result.success) {
                        this.sceneManager = this.transitionController.sceneManager;
                        this.audioSceneController = this.transitionController.audioSceneController;
                        this.isInitialized = true;
                        
                        this.log('âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†', 'success');
                        this.updateStatus('initStatus', 'ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº† - æº–å‚™å®Œäº†');
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    this.log(`âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—: ${error.message}`, 'error');
                    this.updateStatus('initStatus', `åˆæœŸåŒ–å¤±æ•—: ${error.message}`);
                }
            }
            
            async initializeAudio() {
                try {
                    this.log('ğŸµ éŸ³éŸ¿ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹...', 'info');
                    
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                        this.log('âœ… Tone.js AudioContexté–‹å§‹', 'success');
                    }
                    
                    this.mockAudioManager.isInitialized = true;
                    this.log('âœ… éŸ³éŸ¿ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†', 'success');
                    
                } catch (error) {
                    this.log(`âŒ éŸ³éŸ¿åˆæœŸåŒ–å¤±æ•—: ${error.message}`, 'error');
                }
            }
            
            async transitionTo(targetScene) {
                if (!this.isInitialized) {
                    this.log('âš ï¸ ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                    return;
                }
                
                try {
                    this.log(`ğŸ¬ ã‚·ãƒ¼ãƒ³é·ç§»é–‹å§‹: â†’ ${targetScene}`, 'info');
                    
                    const result = await this.transitionController.transitionTo(targetScene);
                    
                    if (result.success) {
                        this.log(`âœ… ã‚·ãƒ¼ãƒ³é·ç§»å®Œäº†: ${result.fromScene} â†’ ${result.toScene} (${result.duration}ms)`, 'success');
                    } else {
                        this.log(`âŒ ã‚·ãƒ¼ãƒ³é·ç§»å¤±æ•—: ${result.error}`, 'error');
                    }
                } catch (error) {
                    this.log(`âŒ é·ç§»ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            async testBGMSwitching() {
                this.log('ğŸµ BGMåˆ‡ã‚Šæ›¿ãˆãƒ†ã‚¹ãƒˆé–‹å§‹...', 'info');
                
                const scenes = ['menu', 'characterSelect', 'playing'];
                for (const scene of scenes) {
                    await this.transitionTo(scene);
                    await this.delay(1000);
                }
                
                this.log('âœ… BGMåˆ‡ã‚Šæ›¿ãˆãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
            }
            
            async testCrossfade() {
                this.log('ğŸ¶ ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆé–‹å§‹...', 'info');
                
                await this.transitionTo('menu');
                await this.delay(500);
                await this.transitionTo('playing');
                await this.delay(500);
                await this.transitionTo('characterSelect');
                
                this.log('âœ… ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
            }
            
            async testVolumeControl() {
                this.log('ğŸ”Š éŸ³é‡èª¿æ•´ãƒ†ã‚¹ãƒˆé–‹å§‹...', 'info');
                
                const volumes = [0.1, 0.5, 0.8, 0.3];
                for (const volume of volumes) {
                    await this.mockAudioManager.setBGMVolume(volume);
                    this.log(`éŸ³é‡èª¿æ•´: ${volume}`, 'info');
                    await this.delay(300);
                }
                
                this.log('âœ… éŸ³é‡èª¿æ•´ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
            }
            
            async testEffects() {
                this.log('ğŸ­ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚¹ãƒˆé–‹å§‹...', 'info');
                
                await this.transitionTo('paused');  // lowpass effect
                await this.delay(500);
                await this.transitionTo('playing'); // compressor effect
                
                this.log('âœ… ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
            }
            
            checkStatus() {
                if (!this.isInitialized) {
                    this.updateStatus('initStatus', 'æœªåˆæœŸåŒ–çŠ¶æ…‹');
                    return;
                }
                
                const state = this.transitionController.getCurrentState();
                const debug = this.transitionController.getDebugInfo();
                
                this.updateStatus('initStatus', JSON.stringify(debug, null, 2));
                this.log('ğŸ“Š çŠ¶æ…‹ç¢ºèªå®Œäº†', 'info');
            }
            
            updateDisplays() {
                if (!this.isInitialized) return;
                
                try {
                    // ç¾åœ¨ã®çŠ¶æ…‹è¡¨ç¤º
                    const currentState = this.transitionController.getCurrentState();
                    const stateHTML = `
Current Scene: ${currentState.currentScene}
Previous Scene: ${currentState.previousScene}
Is Transitioning: ${currentState.isTransitioning}
Queue Size: ${currentState.queueSize}
Audio BGM: ${currentState.audioState.bgmTrack || 'none'}
Audio Volume: BGM ${currentState.audioState.bgmVolume}, SFX ${currentState.audioState.sfxVolume}
Mock Audio BGM: ${this.mockAudioManager.currentBGM || 'none'}
                    `;
                    document.getElementById('stateDisplay').textContent = stateHTML;
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ
                    const perf = this.transitionController.getPerformanceInfo();
                    document.getElementById('transitionStats').innerHTML = `
                        ç·é·ç§»æ•°: ${perf.totalTransitions}<br>
                        æˆåŠŸæ•°: ${perf.successfulTransitions}<br>
                        å¤±æ•—æ•°: ${perf.failedTransitions}<br>
                        å¹³å‡æ™‚é–“: ${perf.averageTransitionTime.toFixed(1)}ms
                    `;
                    
                    document.getElementById('audioPerf').innerHTML = `
                        BGM: ${this.mockAudioManager.currentBGM || 'none'}<br>
                        éŸ³é‡: ${JSON.stringify(this.mockAudioManager.volume)}<br>
                        åˆæœŸåŒ–æ¸ˆã¿: ${this.mockAudioManager.isInitialized}
                    `;
                    
                    document.getElementById('systemState').innerHTML = `
                        åˆæœŸåŒ–æ¸ˆã¿: ${this.isInitialized}<br>
                        ãƒ­ã‚°æ•°: ${this.logs.length}<br>
                        Tone.js: ${Tone.context.state}
                    `;
                } catch (error) {
                    console.error('Display update error:', error);
                }
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = { message, type, timestamp };
                this.logs.push(logEntry);
                
                // ãƒ­ã‚°è¡¨ç¤ºæ›´æ–°
                const logOutput = document.getElementById('logOutput');
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry log-${type}`;
                logDiv.textContent = `[${timestamp}] ${message}`;
                
                logOutput.appendChild(logDiv);
                logOutput.scrollTop = logOutput.scrollHeight;
                
                // ãƒ­ã‚°æ•°åˆ¶é™
                if (this.logs.length > 100) {
                    this.logs.shift();
                    logOutput.removeChild(logOutput.firstChild);
                }
                
                console.log(`[Phase3.1Test] ${message}`);
            }
            
            updateStatus(elementId, text) {
                document.getElementById(elementId).textContent = text;
            }
            
            clearLogs() {
                this.logs = [];
                document.getElementById('logOutput').innerHTML = 'ãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†';
                this.log('ğŸ§¹ ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
            }
            
            exportLogs() {
                const logsText = this.logs.map(log => 
                    `[${log.timestamp}] [${log.type.toUpperCase()}] ${log.message}`
                ).join('\n');
                
                const blob = new Blob([logsText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phase31-test-logs-${Date.now()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('ğŸ“¤ ãƒ­ã‚°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ é–‹å§‹
        const testSystem = new Phase31TestSystem();
        window.testSystem = testSystem; // ãƒ‡ãƒãƒƒã‚°ç”¨
    </script>
</body>
</html>
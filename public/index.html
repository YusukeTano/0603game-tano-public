<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project: Void Rusher</title>
    <style>
        /* ------ CSS SECTION ------ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #game-canvas {
            border: 2px solid #00FFFF;
            box-shadow: 0 0 20px #00FFFF;
            background: #000;
        }
        
        /* UI Elements */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            color: white;
            font-family: 'Courier New', monospace;
        }
        
        .ui-overlay > * {
            pointer-events: auto;
        }
        
        /* HUD Elements */
        .hud-top {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #00FFFF;
        }
        
        .hud-bottom-left {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00FFFF;
        }
        
        .hud-bottom-right {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00FFFF;
        }
        
        .hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00FFFF;
        }
        
        /* Progress Bars */
        .progress-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00FFFF;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .xp-gauge-fill {
            background: linear-gradient(90deg, #00ffff, #0088ff);
        }
        
        .hp-bar-fill {
            background: #00ffff;
        }
        
        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
        }
        
        .screen.hidden {
            display: none;
        }
        
        .screen h1 {
            font-size: 3em;
            color: #00FFFF;
            text-shadow: 0 0 20px #00FFFF;
            margin-bottom: 2em;
            animation: pulse 2s infinite;
        }
        
        .screen h2 {
            font-size: 2em;
            color: #FFFFFF;
            margin-bottom: 1em;
        }
        
        .menu-button {
            background: linear-gradient(45deg, #000428, #004e92);
            border: 2px solid #00FFFF;
            color: #FFFFFF;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            margin: 10px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .menu-button:hover {
            background: linear-gradient(45deg, #004e92, #000428);
            box-shadow: 0 0 20px #00FFFF;
            transform: scale(1.05);
        }
        
        .character-select-container {
            display: flex;
            gap: 50px;
            margin: 30px 0;
        }
        
        .character-option {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            min-width: 200px;
        }
        
        .character-option:hover,
        .character-option.selected {
            border-color: #00FFFF;
            box-shadow: 0 0 20px #00FFFF;
        }
        
        .character-option h3 {
            color: #00FFFF;
            margin-bottom: 10px;
        }
        
        .character-option .character-preview {
            width: 100px;
            height: 100px;
            margin: 10px auto;
            border: 1px solid #666;
            border-radius: 5px;
        }
        
        /* Minimap */
        .minimap {
            width: 150px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00FFFF;
            border-radius: 5px;
        }
        
        /* Skill Icons */
        .skill-icons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            max-width: 200px;
        }
        
        .skill-icon {
            width: 30px;
            height: 30px;
            background: rgba(0, 255, 255, 0.3);
            border: 1px solid #00FFFF;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #00FFFF;
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px #00FFFF; }
            50% { box-shadow: 0 0 40px #00FFFF; }
        }
        
        /* Pause Menu */
        .pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            padding: 30px;
            z-index: 30;
        }
        
        .pause-menu.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="1200" height="800"></canvas>
    
    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- HUD Elements -->
        <div class="hud-top">
            <div>時間: <span id="time-display">00:00</span></div>
            <div>レベル: <span id="level-display">1</span></div>
            <div>討伐数: <span id="kills-display">0</span></div>
            <div>スコア: <span id="score-display">0</span></div>
            <div class="progress-bar">
                <div class="progress-fill xp-gauge-fill" id="xp-bar" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="hud-bottom-left">
            <div>HP:</div>
            <div class="progress-bar">
                <div class="progress-fill hp-bar-fill" id="hp-bar" style="width: 100%"></div>
            </div>
        </div>
        
        <div class="hud-bottom-right">
            <div>スキル:</div>
            <div class="skill-icons" id="skill-icons">
                <!-- スキルアイコンが動的に追加される -->
            </div>
        </div>
        
        <div class="hud-top-right">
            <div>ミニマップ:</div>
            <canvas class="minimap" id="minimap" width="150" height="100"></canvas>
        </div>
    </div>
    
    <!-- Title Screen -->
    <div class="screen" id="title-screen">
        <h1>Project: Void Rusher</h1>
        <button class="menu-button" onclick="showCharacterSelect()">START</button>
    </div>
    
    <!-- Character Select Screen -->
    <div class="screen hidden" id="character-select-screen">
        <h2>機体選択</h2>
        <div class="character-select-container">
            <div class="character-option" onclick="selectCharacter('strider')" id="strider-option">
                <h3>Strider-V</h3>
                <div class="character-preview" id="strider-preview"></div>
                <p>先進型迎撃機</p>
                <p>攻撃・機動力特化</p>
            </div>
            <div class="character-option" onclick="selectCharacter('pico')" id="pico-option">
                <h3>Pico-Rabbit</h3>
                <div class="character-preview" id="pico-preview"></div>
                <p>自律式ペットドローン</p>
                <p>サポート・生存特化</p>
            </div>
        </div>
        <button class="menu-button" onclick="startGame()" id="start-game-btn" disabled>ゲーム開始</button>
    </div>
    
    <!-- Game Over Screen -->
    <div class="screen hidden" id="game-over-screen">
        <h1>GAME OVER</h1>
        <div id="result-panel">
            <p>生存時間: <span id="final-time">00:00</span></p>
            <p>最終スコア: <span id="final-score">0</span></p>
            <p>総討伐数: <span id="final-kills">0</span></p>
            <p>到達レベル: <span id="final-level">1</span></p>
        </div>
        <button class="menu-button" onclick="retry()">リトライ</button>
        <button class="menu-button" onclick="backToTitle()">タイトルへ戻る</button>
    </div>
    
    <!-- Pause Menu -->
    <div class="pause-menu hidden" id="pause-menu">
        <h2>一時停止</h2>
        <button class="menu-button" onclick="resumeGame()">ゲームに戻る</button>
        <button class="menu-button" onclick="backToTitle()">タイトルへ戻る</button>
    </div>

    <script>
        /* ------ JAVASCRIPT SECTION ------ */
        
        // ゲーム状態管理 (README §5)
        const gameState = {
            currentScreen: 'title',
            player: {
                x: 6000,
                y: 4000,
                characterType: null,
                rotation: 0,
                hp: 100,
                maxHp: 100,
                level: 1,
                xp: 0,
                xpToNext: 100,
                score: 0,
                kills: 0,
                speed: 5
            },
            world: {
                width: 12000,
                height: 8000,
                camera: { x: 0, y: 0 }
            },
            deadlyZone: {
                isInside: true,
                damageRate: 0.5
            },
            boss: {
                exists: false,
                spawnTime: 120,
                currentPhase: 1,
                isInvulnerable: true
            },
            gameTime: 0,
            isPaused: false,
            isGameOver: false,
            enemies: [],
            projectiles: [],
            items: [],
            skills: [],
            particles: []
        };
        
        // Canvas設定
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // Audio Context (README §7)
        let audioContext;
        let bgmNodes = {};
        
        // オブジェクトプール (README §9.3)
        class ObjectPool {
            constructor(createFn, resetFn, size = 100) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                
                for (let i = 0; i < size; i++) {
                    this.pool.push(createFn());
                }
            }
            
            acquire() {
                const obj = this.pool.pop() || this.createFn();
                this.active.push(obj);
                return obj;
            }
            
            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.resetFn(obj);
                    this.pool.push(obj);
                }
            }
        }
        
        // プレイヤークラス (README §10.1)
        class Player {
            constructor(type) {
                this.type = type;
                this.x = gameState.player.x;
                this.y = gameState.player.y;
                this.rotation = 0;
                this.targetX = this.x;
                this.targetY = this.y;
                this.lastShotTime = 0;
                this.shotInterval = 200; // ms
                
                if (type === 'strider') {
                    this.color = '#C0C0C0';
                    this.accentColor = '#00FFFF';
                    this.maxHp = 100;
                    this.attackPower = 25;
                    this.speed = 6;
                } else if (type === 'pico') {
                    this.color = '#FFC0CB';
                    this.accentColor = '#FFFFFF';
                    this.maxHp = 150;
                    this.attackPower = 20;
                    this.speed = 5;
                }
                
                gameState.player.maxHp = this.maxHp;
                gameState.player.hp = this.maxHp;
                gameState.player.speed = this.speed;
            }
            
            update(mouseX, mouseY) {
                // マウス追従移動 (README §5.2)
                this.targetX = mouseX + gameState.world.camera.x - canvas.width / 2;
                this.targetY = mouseY + gameState.world.camera.y - canvas.height / 2;
                
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    const speed = Math.min(this.speed, distance * 0.1);
                    this.x += (dx / distance) * speed;
                    this.y += (dy / distance) * speed;
                }
                
                // カメラ更新
                gameState.world.camera.x = this.x - canvas.width / 2;
                gameState.world.camera.y = this.y - canvas.height / 2;
                
                // 境界チェック (README §5.1)
                this.checkBoundaries();
                
                // 最近敵への自動照準 (README §5.3)
                this.autoAim();
                
                // 自動攻撃
                this.autoAttack();
                
                // ゲーム状態同期
                gameState.player.x = this.x;
                gameState.player.y = this.y;
                gameState.player.rotation = this.rotation;
            }
            
            checkBoundaries() {
                const margin = 100;
                gameState.deadlyZone.isInside = (
                    this.x >= margin && this.x <= gameState.world.width - margin &&
                    this.y >= margin && this.y <= gameState.world.height - margin
                );
                
                if (!gameState.deadlyZone.isInside) {
                    // 境界ダメージ
                    if (Math.random() < 0.02) {
                        gameState.player.hp -= gameState.deadlyZone.damageRate;
                        this.createDamageEffect();
                    }
                }
            }
            
            autoAim() {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - this.x;
                    const dy = nearestEnemy.y - this.y;
                    this.rotation = Math.atan2(dy, dx);
                }
            }
            
            autoAttack() {
                const now = Date.now();
                if (now - this.lastShotTime > this.shotInterval) {
                    this.shoot();
                    this.lastShotTime = now;
                }
            }
            
            shoot() {
                const projectile = {
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(this.rotation) * 10,
                    vy: Math.sin(this.rotation) * 10,
                    damage: this.attackPower,
                    lifetime: 60,
                    color: this.accentColor
                };
                gameState.projectiles.push(projectile);
                
                // 攻撃音再生
                playSound('playerAttack');
            }
            
            createDamageEffect() {
                // ダメージエフェクト生成
                for (let i = 0; i < 5; i++) {
                    gameState.particles.push({
                        x: this.x + (Math.random() - 0.5) * 40,
                        y: this.y + (Math.random() - 0.5) * 40,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        color: '#FF0000',
                        lifetime: 30,
                        maxLifetime: 30
                    });
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - gameState.world.camera.x, this.y - gameState.world.camera.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'strider') {
                    this.drawStrider();
                } else if (this.type === 'pico') {
                    this.drawPico();
                }
                
                ctx.restore();
            }
            
            drawStrider() {
                // Strider-V描画 (README §10.1.1)
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.accentColor;
                
                // 本体（矢じり型）
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(15, -8);
                ctx.lineTo(10, 0);
                ctx.lineTo(15, 8);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // 翼
                ctx.beginPath();
                ctx.moveTo(-10, -8);
                ctx.bezierCurveTo(-20, -12, -25, -8, -20, -4);
                ctx.lineTo(-10, -4);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-10, 8);
                ctx.bezierCurveTo(-20, 12, -25, 8, -20, 4);
                ctx.lineTo(-10, 4);
                ctx.closePath();
                ctx.fill();
                
                // エネルギーコア
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fillStyle = this.accentColor;
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            drawPico() {
                // Pico-Rabbit描画 (README §10.1.2)
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.accentColor;
                
                // 胴体（円形）
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // 耳（ぴょこぴょこアニメーション）
                const earOffset = Math.sin(Date.now() * 0.01) * 2;
                
                // 左耳
                ctx.beginPath();
                ctx.ellipse(-8, -10 + earOffset, 3, 8, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // 右耳
                ctx.beginPath();
                ctx.ellipse(8, -10 + earOffset, 3, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // 目
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-4, -2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(4, -2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }
        
        // 敵クラス (README §10.2)
        class Enemy {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.hp = 100;
                this.maxHp = 100;
                this.rotation = 0;
                this.lastActionTime = 0;
                this.isAlive = true;
                
                this.setupType();
            }
            
            setupType() {
                switch (this.type) {
                    case 'crawler':
                        this.color = '#CC6600';
                        this.accentColor = '#FF9900';
                        this.hp = this.maxHp = 50;
                        this.speed = 2;
                        this.size = 15;
                        break;
                    case 'slasher':
                        this.color = '#CCCC00';
                        this.accentColor = '#FFFF00';
                        this.hp = this.maxHp = 30;
                        this.speed = 4;
                        this.size = 12;
                        break;
                    case 'spitter':
                        this.color = '#8B008B';
                        this.accentColor = '#FF00FF';
                        this.hp = this.maxHp = 60;
                        this.speed = 1;
                        this.size = 18;
                        break;
                    case 'bulwark':
                        this.color = '#8B0000';
                        this.accentColor = '#FF0000';
                        this.hp = this.maxHp = 200;
                        this.speed = 0.8;
                        this.size = 25;
                        break;
                }
            }
            
            update() {
                if (!this.isAlive) return;
                
                const player = gameState.player;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                this.rotation = Math.atan2(dy, dx);
                
                switch (this.type) {
                    case 'crawler':
                        this.updateCrawler(dx, dy, distance);
                        break;
                    case 'slasher':
                        this.updateSlasher(dx, dy, distance);
                        break;
                    case 'spitter':
                        this.updateSpitter(dx, dy, distance);
                        break;
                    case 'bulwark':
                        this.updateBulwark(dx, dy, distance);
                        break;
                }
                
                this.x += this.vx;
                this.y += this.vy;
            }
            
            updateCrawler(dx, dy, distance) {
                if (distance > 5) {
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                }
            }
            
            updateSlasher(dx, dy, distance) {
                const now = Date.now();
                if (now - this.lastActionTime > 2000) {
                    // 急転換攻撃
                    this.vx = (dx / distance) * this.speed * 2;
                    this.vy = (dy / distance) * this.speed * 2;
                    this.lastActionTime = now;
                } else {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
            }
            
            updateSpitter(dx, dy, distance) {
                const now = Date.now();
                
                // 一定距離を保持
                if (distance < 200) {
                    this.vx = -(dx / distance) * this.speed;
                    this.vy = -(dy / distance) * this.speed;
                } else {
                    this.vx *= 0.9;
                    this.vy *= 0.9;
                }
                
                // 遠距離攻撃
                if (now - this.lastActionTime > 3000 && distance < 400) {
                    this.shoot(dx, dy, distance);
                    this.lastActionTime = now;
                }
            }
            
            updateBulwark(dx, dy, distance) {
                if (distance > 10) {
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                }
            }
            
            shoot(dx, dy, distance) {
                const projectile = {
                    x: this.x,
                    y: this.y,
                    vx: (dx / distance) * 6,
                    vy: (dy / distance) * 6,
                    damage: 20,
                    lifetime: 100,
                    color: this.accentColor,
                    isEnemyProjectile: true
                };
                gameState.projectiles.push(projectile);
            }
            
            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }
            
            destroy() {
                this.isAlive = false;
                
                // 経験値ジェム生成
                gameState.items.push({
                    type: 'xp',
                    x: this.x,
                    y: this.y,
                    value: 10,
                    lifetime: 300
                });
                
                // 破壊エフェクト
                for (let i = 0; i < 10; i++) {
                    gameState.particles.push({
                        x: this.x + (Math.random() - 0.5) * 20,
                        y: this.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: this.accentColor,
                        lifetime: 30,
                        maxLifetime: 30
                    });
                }
                
                gameState.player.kills++;
                gameState.player.score += 100;
                
                playSound('enemyDestroy');
            }
            
            draw() {
                if (!this.isAlive) return;
                
                const screenX = this.x - gameState.world.camera.x;
                const screenY = this.y - gameState.world.camera.y;
                
                // 画面外カリング
                if (screenX < -50 || screenX > canvas.width + 50 || 
                    screenY < -50 || screenY > canvas.height + 50) {
                    return;
                }
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.accentColor;
                
                switch (this.type) {
                    case 'crawler':
                        this.drawCrawler();
                        break;
                    case 'slasher':
                        this.drawSlasher();
                        break;
                    case 'spitter':
                        this.drawSpitter();
                        break;
                    case 'bulwark':
                        this.drawBulwark();
                        break;
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            
            drawCrawler() {
                // 立方体 + モノアイ
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                
                ctx.fillStyle = this.accentColor;
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawSlasher() {
                // 菱形
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.lineTo(0, -this.size/2);
                ctx.lineTo(this.size, 0);
                ctx.lineTo(0, this.size/2);
                ctx.closePath();
                ctx.fill();
                
                // 噴射光
                ctx.strokeStyle = this.accentColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.lineTo(-this.size*2, 0);
                ctx.stroke();
            }
            
            drawSpitter() {
                // 六角形
                ctx.fillStyle = this.color;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI * 2) / 6;
                    const x = Math.cos(angle) * this.size;
                    const y = Math.sin(angle) * this.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // 三重丸砲口
                ctx.strokeStyle = this.accentColor;
                ctx.lineWidth = 2;
                for (let i = 1; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, i * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            drawBulwark() {
                // 十字型
                ctx.fillStyle = this.color;
                
                // 縦棒
                ctx.fillRect(-5, -this.size, 10, this.size * 2);
                
                // 横棒
                ctx.fillRect(-this.size, -5, this.size * 2, 10);
                
                // 先端装甲
                ctx.fillRect(-this.size-5, -8, 10, 16);
                ctx.fillRect(this.size-5, -8, 10, 16);
                ctx.fillRect(-8, -this.size-5, 16, 10);
                ctx.fillRect(-8, this.size-5, 16, 10);
            }
        }
        
        // Audio System (README §7.2)
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Web Audio API not supported');
            }
        }
        
        function playSound(type) {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            switch (type) {
                case 'playerAttack':
                    // ノコギリ波でピッチ急降下
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(800, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    break;
                    
                case 'enemyHit':
                    // 短い矩形波
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, audioContext.currentTime);
                    gain.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                    break;
                    
                case 'enemyDestroy':
                    // ホワイトノイズ + 低周波
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioContext.currentTime);
                    gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                    break;
                    
                case 'levelUp':
                    // 三角波アルペジオ
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(440, audioContext.currentTime);
                    osc.frequency.setValueAtTime(554, audioContext.currentTime + 0.1);
                    osc.frequency.setValueAtTime(659, audioContext.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.6);
                    break;
                    
                case 'itemPickup':
                    // 三角波「ピコン」
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(880, audioContext.currentTime);
                    gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                    break;
            }
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.6);
        }
        
        // Game Logic
        let player = null;
        let mouseX = 0, mouseY = 0;
        let selectedCharacter = null;
        
        // UI Functions
        function showCharacterSelect() {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('character-select-screen').classList.remove('hidden');
            gameState.currentScreen = 'character-select';
            
            // キャラクタープレビュー描画
            drawCharacterPreview('strider', document.getElementById('strider-preview'));
            drawCharacterPreview('pico', document.getElementById('pico-preview'));
        }
        
        function selectCharacter(type) {
            selectedCharacter = type;
            
            // 選択状態の表示更新
            document.querySelectorAll('.character-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.getElementById(type + '-option').classList.add('selected');
            document.getElementById('start-game-btn').disabled = false;
        }
        
        function startGame() {
            if (!selectedCharacter) return;
            
            // 音声初期化
            initAudio();
            
            // ゲーム状態初期化
            gameState.currentScreen = 'game';
            gameState.player.characterType = selectedCharacter;
            gameState.gameTime = 0;
            gameState.isPaused = false;
            gameState.isGameOver = false;
            
            // プレイヤー作成
            player = new Player(selectedCharacter);
            
            // 画面切り替え
            document.getElementById('character-select-screen').classList.add('hidden');
            
            // ゲームループ開始
            requestAnimationFrame(gameLoop);
        }
        
        function pauseGame() {
            if (gameState.currentScreen !== 'game' || gameState.isGameOver) return;
            
            gameState.isPaused = true;
            document.getElementById('pause-menu').classList.remove('hidden');
        }
        
        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pause-menu').classList.add('hidden');
        }
        
        function gameOver() {
            gameState.isGameOver = true;
            gameState.currentScreen = 'game-over';
            
            // リザルト表示
            document.getElementById('final-time').textContent = formatTime(gameState.gameTime);
            document.getElementById('final-score').textContent = gameState.player.score;
            document.getElementById('final-kills').textContent = gameState.player.kills;
            document.getElementById('final-level').textContent = gameState.player.level;
            
            document.getElementById('game-over-screen').classList.remove('hidden');
        }
        
        function retry() {
            // ゲーム状態リセット
            gameState.player = {
                x: 6000, y: 4000, characterType: selectedCharacter,
                rotation: 0, hp: 100, maxHp: 100, level: 1, xp: 0, xpToNext: 100,
                score: 0, kills: 0, speed: 5
            };
            gameState.world.camera = { x: 0, y: 0 };
            gameState.gameTime = 0;
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.items = [];
            gameState.particles = [];
            
            document.getElementById('game-over-screen').classList.add('hidden');
            startGame();
        }
        
        function backToTitle() {
            // 全画面を隠す
            document.querySelectorAll('.screen, .pause-menu').forEach(screen => {
                screen.classList.add('hidden');
            });
            
            // タイトル画面表示
            document.getElementById('title-screen').classList.remove('hidden');
            gameState.currentScreen = 'title';
            
            // ゲーム状態リセット
            gameState.isGameOver = false;
            gameState.isPaused = false;
            selectedCharacter = null;
            player = null;
        }
        
        // Input Handling
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (gameState.currentScreen === 'game' && !gameState.isGameOver) {
                    if (gameState.isPaused) {
                        resumeGame();
                    } else {
                        pauseGame();
                    }
                }
            }
        });
        
        // Game Loop
        function gameLoop() {
            if (gameState.currentScreen !== 'game') return;
            
            if (!gameState.isPaused && !gameState.isGameOver) {
                update();
            }
            
            render();
            
            if (!gameState.isGameOver) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function update() {
            gameState.gameTime++;
            
            // プレイヤー更新
            if (player) {
                player.update(mouseX, mouseY);
            }
            
            // 敵生成
            spawnEnemies();
            
            // 敵更新
            gameState.enemies.forEach(enemy => enemy.update());
            gameState.enemies = gameState.enemies.filter(enemy => enemy.isAlive);
            
            // 弾丸更新
            updateProjectiles();
            
            // アイテム更新
            updateItems();
            
            // パーティクル更新
            updateParticles();
            
            // 当たり判定
            checkCollisions();
            
            // HP確認
            if (gameState.player.hp <= 0) {
                gameOver();
            }
            
            // HUD更新
            updateHUD();
        }
        
        function spawnEnemies() {
            if (Math.random() < 0.02) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 400 + Math.random() * 200;
                const x = gameState.player.x + Math.cos(angle) * distance;
                const y = gameState.player.y + Math.sin(angle) * distance;
                
                const types = ['crawler', 'slasher', 'spitter', 'bulwark'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                gameState.enemies.push(new Enemy(type, x, y));
            }
        }
        
        function updateProjectiles() {
            gameState.projectiles.forEach(projectile => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;
                projectile.lifetime--;
            });
            
            gameState.projectiles = gameState.projectiles.filter(p => p.lifetime > 0);
        }
        
        function updateItems() {
            gameState.items.forEach(item => {
                // プレイヤーとの距離チェック
                const dx = item.x - gameState.player.x;
                const dy = item.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 30) {
                    // アイテム取得
                    if (item.type === 'xp') {
                        gameState.player.xp += item.value;
                        playSound('itemPickup');
                        
                        // レベルアップチェック
                        if (gameState.player.xp >= gameState.player.xpToNext) {
                            levelUp();
                        }
                    }
                    item.lifetime = 0;
                }
                
                item.lifetime--;
            });
            
            gameState.items = gameState.items.filter(item => item.lifetime > 0);
        }
        
        function updateParticles() {
            gameState.particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                particle.lifetime--;
            });
            
            gameState.particles = gameState.particles.filter(p => p.lifetime > 0);
        }
        
        function checkCollisions() {
            // プレイヤー弾 vs 敵
            gameState.projectiles.forEach(projectile => {
                if (projectile.isEnemyProjectile) return;
                
                gameState.enemies.forEach(enemy => {
                    if (!enemy.isAlive) return;
                    
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size) {
                        if (enemy.takeDamage(projectile.damage)) {
                            playSound('enemyDestroy');
                        } else {
                            playSound('enemyHit');
                        }
                        projectile.lifetime = 0;
                    }
                });
            });
            
            // 敵弾 vs プレイヤー
            gameState.projectiles.forEach(projectile => {
                if (!projectile.isEnemyProjectile) return;
                
                const dx = projectile.x - gameState.player.x;
                const dy = projectile.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 20) {
                    gameState.player.hp -= projectile.damage;
                    player.createDamageEffect();
                    projectile.lifetime = 0;
                }
            });
        }
        
        function levelUp() {
            gameState.player.level++;
            gameState.player.xp = 0;
            gameState.player.xpToNext = Math.floor(gameState.player.xpToNext * 1.2);
            
            playSound('levelUp');
            
            // レベルアップエフェクト
            for (let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: gameState.player.x + (Math.random() - 0.5) * 60,
                    y: gameState.player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: '#00FFFF',
                    lifetime: 60,
                    maxLifetime: 60
                });
            }
        }
        
        function updateHUD() {
            document.getElementById('time-display').textContent = formatTime(gameState.gameTime);
            document.getElementById('level-display').textContent = gameState.player.level;
            document.getElementById('kills-display').textContent = gameState.player.kills;
            document.getElementById('score-display').textContent = gameState.player.score;
            
            // XPゲージ
            const xpPercent = (gameState.player.xp / gameState.player.xpToNext) * 100;
            document.getElementById('xp-bar').style.width = xpPercent + '%';
            
            // HPバー
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            const hpBar = document.getElementById('hp-bar');
            hpBar.style.width = hpPercent + '%';
            
            // HP色変化
            if (hpPercent > 60) {
                hpBar.style.background = '#00ffff';
            } else if (hpPercent > 30) {
                hpBar.style.background = '#ffff00';
            } else {
                hpBar.style.background = '#ff0000';
            }
        }
        
        function formatTime(frames) {
            const seconds = Math.floor(frames / 60);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // Rendering
        function render() {
            // メインキャンバスクリア
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState.currentScreen === 'game') {
                // 背景描画
                drawBackground();
                
                // プレイヤー描画
                if (player) {
                    player.draw();
                }
                
                // 敵描画
                gameState.enemies.forEach(enemy => enemy.draw());
                
                // 弾丸描画
                drawProjectiles();
                
                // アイテム描画
                drawItems();
                
                // パーティクル描画
                drawParticles();
                
                // 境界警告
                drawBoundaryWarning();
                
                // ミニマップ描画
                drawMinimap();
            }
        }
        
        function drawBackground() {
            // パララックス背景 (README §10.4)
            const time = gameState.gameTime * 0.01;
            
            // レイヤー1: 遠景の星々
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < 50; i++) {
                const x = ((i * 73 + time * 0.1) % canvas.width);
                const y = ((i * 97) % canvas.height);
                ctx.fillRect(x, y, 1, 1);
            }
            
            // レイヤー2: 中景の星雲
            ctx.fillStyle = 'rgba(100, 100, 255, 0.3)';
            for (let i = 0; i < 20; i++) {
                const x = ((i * 113 + time * 0.3) % (canvas.width + 100)) - 50;
                const y = ((i * 127) % (canvas.height + 100)) - 50;
                ctx.beginPath();
                ctx.arc(x, y, 20 + Math.sin(time + i) * 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawProjectiles() {
            gameState.projectiles.forEach(projectile => {
                const screenX = projectile.x - gameState.world.camera.x;
                const screenY = projectile.y - gameState.world.camera.y;
                
                ctx.fillStyle = projectile.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = projectile.color;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            });
        }
        
        function drawItems() {
            gameState.items.forEach(item => {
                const screenX = item.x - gameState.world.camera.x;
                const screenY = item.y - gameState.world.camera.y;
                
                if (item.type === 'xp') {
                    // 経験値ジェム (README §10.3)
                    ctx.fillStyle = '#00FFFF';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00FFFF';
                    
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(gameState.gameTime * 0.1);
                    
                    // クリスタル形状
                    ctx.beginPath();
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(-4, -6);
                    ctx.lineTo(4, -6);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(4, 6);
                    ctx.lineTo(-4, 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        function drawParticles() {
            gameState.particles.forEach(particle => {
                const screenX = particle.x - gameState.world.camera.x;
                const screenY = particle.y - gameState.world.camera.y;
                
                const alpha = particle.lifetime / particle.maxLifetime;
                ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawBoundaryWarning() {
            if (!gameState.deadlyZone.isInside) {
                // 画面端を赤くフラッシュ
                const alpha = Math.sin(gameState.gameTime * 0.3) * 0.3 + 0.3;
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                
                // 画面四隅に警告
                ctx.fillRect(0, 0, canvas.width, 20);
                ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
                ctx.fillRect(0, 0, 20, canvas.height);
                ctx.fillRect(canvas.width - 20, 0, 20, canvas.height);
            }
        }
        
        function drawMinimap() {
            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, 150, 100);
            
            // ワールド座標からミニマップ座標への変換
            const scaleX = 150 / gameState.world.width;
            const scaleY = 100 / gameState.world.height;
            
            // プレイヤー位置
            const playerMapX = gameState.player.x * scaleX;
            const playerMapY = gameState.player.y * scaleY;
            
            minimapCtx.fillStyle = gameState.player.characterType === 'strider' ? '#00FFFF' : '#FFC0CB';
            minimapCtx.fillRect(playerMapX - 2, playerMapY - 2, 4, 4);
            
            // 敵位置
            minimapCtx.fillStyle = '#FF0000';
            gameState.enemies.forEach(enemy => {
                const enemyMapX = enemy.x * scaleX;
                const enemyMapY = enemy.y * scaleY;
                minimapCtx.fillRect(enemyMapX - 1, enemyMapY - 1, 2, 2);
            });
            
            // 境界線
            minimapCtx.strokeStyle = gameState.deadlyZone.isInside ? '#00FFFF' : '#FF0000';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(0, 0, 150, 100);
        }
        
        function drawCharacterPreview(type, element) {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, 100, 100);
            
            ctx.save();
            ctx.translate(50, 50);
            
            if (type === 'strider') {
                // Strider-V プレビュー
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00FFFF';
                
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(15, -8);
                ctx.lineTo(10, 0);
                ctx.lineTo(15, 8);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#00FFFF';
                ctx.fill();
                
            } else if (type === 'pico') {
                // Pico-Rabbit プレビュー
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FFFFFF';
                
                ctx.fillStyle = '#FFC0CB';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // 耳
                ctx.beginPath();
                ctx.ellipse(-8, -10, 3, 8, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(8, -10, 3, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            element.innerHTML = '';
            element.appendChild(canvas);
        }
        
        // 初期化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Project: Void Rusher - 初期化完了');
        });
    </script>
</body>
</html>